Our primary backend uses Infiniband Remote Direct Memory Access (RDMA) to talk
to a server managing a large pool of memory. At startup, the remote memory
server maps in a large block of system memory. The server then listens for
connections over the Infiniband fabric. When a client connects, the server
pins the memory in the page table, and registers it with the infiniband drivers.
Registering with the infiniband drivers provides a local key and a remote key.
The server transmits the remote key and starting address to the client.
This allows the client to perform one-sided RDMA operations to the remote
memory without the server's mediation.

In this backend, the \texttt{put()} and \texttt{get()} commands are implemented
using one-sided RDMA writes and reads. The other commands are implemented
using two-sided sends and receives. The client and server each allocate two
message structs: one for sends, and one for receives. In a two-sided send, the
recipient first posts a receive request to the Infiniband driver. This receive
request specifies the local key and address of the receive struct. When the
sender posts a corresponding send request using the local key and address of
its send struct, the infiniband drivers copy the data from the sender's send
struct to the recipients receive struct and notify sender and recipient of the
operation.

The \texttt{malloc()} and \texttt{free()} operations are each implemented using
a pair of sends and receives. First, the client sends an ALLOC or TXN\_FREE
request, respectively, to the server. When the request is processed by the
server, it sends a MEMRESP message (for a malloc) or TXN\_ACK message
(for a free) back to the server. There are also MULTI\_ALLOC and
MULTI\_TXN\_FREE requests which can encode up to 20 allocation or free requests
(this number if configurable at compile time). A key difference in the IB
backend is that frees are transactional. The server does not immediately
perform a free operation when it receives a TXN\_FREE or MULTI\_TXN\_FREE
operation. Instead, it performs all free operation during a commit.

The \texttt{atomic\_commit()} operation involves two different message types.
The first is the MULTI\_TXN\_CP message, which instructs the server to copy
a set of source blocks to a set of destination blocks. However, as with
TXN\_FREE, the copy does not occur immediately. When the client sends the
server a TXN\_GO request, the server performs all requested copies and frees.
In our failure model, we assume that the server will not crash. So even if
the client crashes after sending TXN\_GO, the copies and frees will still be
performed to completion. If the client crashes before sending TXN\_GO, all
of the outstanding copy and free requests will be flushed and no changes will
occur.
